import { pino } from 'pino';
import { Context, Env as Env$1, MiddlewareHandler } from 'hono';
import { IsAny } from 'hono/utils/types';

/**
 * http logger config symbol
 */
declare const httpCfgSym: unique symbol;
/**
 * hono-pino logger instance
 */
interface PinoLogger {
    /**
     * Log at `'trace'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.
     * If more args follows `msg`, these will be used to format `msg` using `util.format`.
     *
     * @typeParam T: the interface of the object being serialized. Default is object.
     * @param obj: object to be serialized
     * @param msg: the log message to write
     * @param ...args: format string values when `msg` is a format string
     */
    trace: pino.LogFn;
    /**
     * Log at `'debug'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.
     * If more args follows `msg`, these will be used to format `msg` using `util.format`.
     *
     * @typeParam T: the interface of the object being serialized. Default is object.
     * @param obj: object to be serialized
     * @param msg: the log message to write
     * @param ...args: format string values when `msg` is a format string
     */
    debug: pino.LogFn;
    /**
     * Log at `'info'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.
     * If more args follows `msg`, these will be used to format `msg` using `util.format`.
     *
     * @typeParam T: the interface of the object being serialized. Default is object.
     * @param obj: object to be serialized
     * @param msg: the log message to write
     * @param ...args: format string values when `msg` is a format string
     */
    info: pino.LogFn;
    /**
     * Log at `'warn'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.
     * If more args follows `msg`, these will be used to format `msg` using `util.format`.
     *
     * @typeParam T: the interface of the object being serialized. Default is object.
     * @param obj: object to be serialized
     * @param msg: the log message to write
     * @param ...args: format string values when `msg` is a format string
     */
    warn: pino.LogFn;
    /**
     * Log at `'error'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.
     * If more args follows `msg`, these will be used to format `msg` using `util.format`.
     *
     * @typeParam T: the interface of the object being serialized. Default is object.
     * @param obj: object to be serialized
     * @param msg: the log message to write
     * @param ...args: format string values when `msg` is a format string
     */
    error: pino.LogFn;
    /**
     * Log at `'fatal'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.
     * If more args follows `msg`, these will be used to format `msg` using `util.format`.
     *
     * @typeParam T: the interface of the object being serialized. Default is object.
     * @param obj: object to be serialized
     * @param msg: the log message to write
     * @param ...args: format string values when `msg` is a format string
     */
    fatal: pino.LogFn;
}
/**
 * hono-pino logger
 */
declare class PinoLogger {
    #private;
    /**
     * Internal pino logger instance
     *
     * If you want to interact with the internal pino logger,
     * you can use it (not recommended)
     */
    _rootLogger: pino.Logger;
    /**
     * Internal child pino logger instance, recreated after each update bindings.
     *
     * If you want to interact with the internal pino logger,
     * you can use it (not recommended)
     */
    _logger: pino.Logger;
    [httpCfgSym]: {
        resMessage?: string | null;
        resLevel?: pino.Level | null;
    };
    constructor(rootLogger: pino.Logger, childOptions?: pino.ChildLoggerOptions);
    /**
     * Get bindings from http log context
     */
    bindings(): pino.Bindings;
    /**
     * Clear bindings from http log context
     */
    clearBindings(): this;
    /**
     * Assign bindings to http log context
     */
    assign(bindings: pino.Bindings, opts?: {
        /** deep merge @default false */
        deep?: boolean;
    }): this;
    /**
     * Override response log message
     */
    setResMessage(message: string | null): this;
    /**
     * Override response log level
     */
    setResLevel(level: pino.Level | null): this;
}

/**
 * pinoLogger options
 */
interface Options<ContextKey extends string = "logger"> {
    /**
     * custom context key
     * @description context key for hono, Must be set to literal string.
     * @default "logger"
     *
     * @example
     *
     * ### default is "logger"
     * ```ts
     * new Hono()
     *   .use(logger())
     *   .get('/', (c) => {
     *     const logger = c.get("logger");
     *     // or destructuring from c.var
     *     const { logger } = c.var.logger;
     *   });
     * ```
     *
     * @example
     *
     * ### custom logger
     * ```ts
     * new Hono()
     *   .use(logger({ contextKey: "myLogger" as const }))
     *   .get('/', (c) => {
     *     const logger = c.get("myLogger");
     *   });
     * ```
     *
     * @example
     *
     * ### multiple logger
     * ```ts
     * new Hono()
     *   .use(logger({ contextKey: "myLogger1" as const }))
     *   .use(logger({ contextKey: "myLogger2" as const }))
     *   .get('/', (c) => {
     *     const logger1 = c.get("myLogger1");
     *     const logger2 = c.get("myLogger2");
     *   })
     * ```
     */
    contextKey?: ContextKey;
    /**
     * a pino instance or pino options
     *
     * @example
     *
     * ### default
     *
     * ```ts
     * {
     *   pino: (c) => ({
     *     level: env(c).LOG_LEVEL ?? "info",
     *   })
     * }
     * ```
     *
     * @example
     *
     * ### a pino logger instance
     *
     * ```ts
     * {
     *   pino: pino({ level: "info" })
     * }
     * ```
     *
     * @example
     *
     * ### a pino options
     *
     * ```ts
     * {
     *   pino: { level: "info" }
     * }
     * ```
     *
     * @example
     *
     * ### a pino destination
     *
     * ```ts
     * {
     *   pino: pino.destination("path/to/log.json")
     * }
     * ```
     *
     * @example
     *
     * ### dynamic pino logger instance
     *
     * this method creates a complete pino logger for each request,
     * which results in relatively lower performance,
     * if possible, recommended to use `dynamic pino child options`.
     *
     * ```ts
     * {
     *   pino: (c) => pino({ level: c.env.LOG_LEVEL })
     * }
     * ```
     *
     * @example
     *
     * ### dynamic pino child options
     *
     * ```ts
     * {
     *   pino: (c) => ({
     *     level: c.env.LOG_LEVEL
     *   } satisfies pino.ChildLoggerOptions)
     * }
     * ```
     */
    pino?: pino.Logger | pino.LoggerOptions | pino.DestinationStream | ((c: Context) => pino.Logger) | ((c: Context) => pino.ChildLoggerOptions);
    /**
     * Specify whether to treat as Node/Bun runtime.
     * - true: Always treat as Node/Bun (do not use getRuntimeKey)
     * - false: Always treat as non-Node/Bun
     * - "auto": Auto-detect (default, will call getRuntimeKey)
     *
     * @default "auto"
     */
    nodeRuntime?: boolean | "auto";
    /**
     * http request log options
     *
     * @description set to false to disable
     */
    http?: false | HttpLoggerOptions;
}
/**
 * http request log options
 */
type HttpLoggerOptions = {
    /**
     * custom request id
     * @deprecated Changed to use referRequestIdKey. will be removed in 1.0.0
     *
     * @description set to false to disable
     * @default () => n + 1
     *
     * @example
     * // UUID v4
     * () => crypto.randomUUID()
     */
    reqId?: false | (() => string);
    /**
     * refer requestId key in context,
     *
     * When the requestId is detected from the context,
     * it will be included in the HTTP logger output.
     *
     * @example
     *
     * ### default use "requestId"
     *
     * ```ts
     * import { requestId } from 'hono/request-id'
     *
     * const app = new Hono()
     *   .use(requestId())
     *   .use(logger()) // it will use `requestId` from requestId middleware
     * ```
     */
    referRequestIdKey?: string;
    /**
     * custom onRequest bindings
     *
     * @example
     *
     * ### default
     *
     * ```ts
     * (c) => ({
     *   req: {
     *     url: c.req.path,
     *     method: c.req.method,
     *     headers: c.req.header(),
     *   },
     * })
     * ```
     *
     * @example
     *
     * ### less headers
     *
     * ```ts
     * (c) => ({
     *   req: {
     *     url: c.req.path,
     *     method: c.req.method,
     *     headers: _.pickBy(
     *       c.req.header(),
     *       (value, key) => _.startsWith(key, "x-")
     *     ),
     *   }
     * })
     * ```
     */
    onReqBindings?: (c: Context) => pino.Bindings;
    /**
     * custom onRequest level
     *
     * @example
     *
     * ### default
     *
     * ```ts
     * (c) => "info"
     * ```
     */
    onReqLevel?: (c: Context) => pino.Level;
    /**
     * custom onRequest message
     *
     * @example
     *
     * ### disable (default)
     *
     * ```ts
     * (c) => false
     * ```
     *
     * @example
     *
     * ### enable
     *
     * ```ts
     * (c) => "Request received"
     * ```
     *
     * @example
     *
     * ### async function to access request body
     *
     * ```ts
     * async (c) => {
     *   const body = await c.req.raw.clone().text();
     *   return `Request received with body: ${body}`;
     * }
     * ```
     */
    onReqMessage?: false | ((c: Context) => string | Promise<string>);
    /**
     * custom onResponse bindings
     *
     * @example
     *
     * ### default
     *
     * ```ts
     * (c) => ({
     *   res: {
     *     status: c.res.status,
     *     headers: c.res.headers,
     *   },
     * })
     * ```
     */
    onResBindings?: (c: Context) => pino.Bindings;
    /**
     * custom onResponse level
     *
     * @example
     *
     * ### default
     *
     * ```ts
     * (c) => c.error ? "error" : "info"
     * ```
     *
     * @example
     *
     * ### always trace
     *
     * ```ts
     * () => "trace"
     * ```
     *
     * @example
     *
     * ### 4xx=warn, 5xx=error, default=info
     *
     * ```ts
     * (c) => {
     *   if (c.status >= 500) return "error"
     *   if (c.status >= 400) return "warn"
     *   return "info"
     * ```
     */
    onResLevel?: (c: Context) => pino.Level;
    /**
     * custom onResponse message
     *
     * @example
     *
     * ### default
     *
     * ```ts
     * (c) => c.error ? c.error.message : "Request completed"
     * ```
     *
     * @example
     *
     * ### disable
     *
     * ```ts
     * false
     * ```
     *
     * @example
     *
     * ### async function
     *
     * ```ts
     * async (c) => {
     *   // Perform async operations
     *   return "Request completed with async processing";
     * }
     * ```
     */
    onResMessage?: false | ((c: Context) => string | Promise<string>);
    /**
     * adding response time to bindings
     *
     * @default true
     */
    responseTime?: boolean;
};
/**
 * hono-pino default env for hono context
 *
 * @example
 *
 * ### with your middleware
 *
 * ```ts
 * import { createMiddleware } from 'hono/factory'
 * import type { Env } from "hono-pino"
 *
 * const middleware = createMiddleware<Env>(async (c, next) => {
 *   const logger = c.get("logger")
 *   await next()
 * })
 * ```
 *
 * @example
 *
 * ### custom context key
 *
 * ```ts
 * import { Hono } from "hono"
 * import { logger, type Env } from "hono-pino"
 *
 * const app = new Hono<Env<"myLogger">>()
 * app.use(logger({ contextKey: "myLogger" as const }))
 * app.get('/', (c) => {
 *   const logger = c.get("myLogger")
 * })
 * ```
 *
 * @example
 *
 * ### merge with your env.
 *
 * ```ts
 * import { Hono } from "hono"
 * import { type Env as HonoPinoEnv } from "hono-pino"
 *
 * type Env = {
 *   Variables: {
 *     foo: string
 *   }
 * }
 *
 * const app = new Hono<Env & HonoPinoEnv>()
 * ```
 */
type Env<LoggerKey extends string = "logger"> = IsAny<LoggerKey> extends true ? any : LoggerKey extends Env$1 ? Env$1 : {
    Variables: {
        [key in LoggerKey]: PinoLogger;
    };
};

/**
 * get logger from context
 * @deprecated Please change to use `c.get("logger")`. will be removed in 1.0.0
 */
declare function getLogger(c: Context): PinoLogger;
/**
 * T must be literal string
 */
type LiteralString<T> = T extends string ? string extends T ? never : T : never;

/**
 * hono-pino middleware
 */
declare const pinoLogger: <ContextKey extends string = "logger">(opts?: Options<LiteralString<ContextKey>>) => MiddlewareHandler<Env<ContextKey>>;
/**
 * Pino logger middleware
 * @deprecated Renamed to pinoLogger, will be removed in 1.0.0
 */
declare const logger: <ContextKey extends string = "logger">(opts?: Options<LiteralString<ContextKey>>) => MiddlewareHandler<Env<ContextKey>>;

export { type Env, type HttpLoggerOptions, type Options, PinoLogger, getLogger, httpCfgSym, logger, pinoLogger };
