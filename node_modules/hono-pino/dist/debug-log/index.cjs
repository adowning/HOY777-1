"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/debug-log/index.ts
var debug_log_exports = {};
__export(debug_log_exports, {
  createHandler: () => createHandler,
  default: () => debug_log_default
});
module.exports = __toCommonJS(debug_log_exports);
var import_pino_abstract_transport = __toESM(require("pino-abstract-transport"), 1);

// src/debug-log/handler.ts
var import_color3 = require("hono/utils/color");
var import_pino = require("pino");

// src/debug-log/formatter.ts
var import_color2 = require("hono/utils/color");

// src/debug-log/utils.ts
var import_color = require("hono/utils/color");
var ANSI = {
  Reset: "\x1B[0m",
  Bright: "\x1B[1m",
  FgWhite: "\x1B[37m",
  FgRed: "\x1B[31m",
  FgGreen: "\x1B[32m",
  FgYellow: "\x1B[33m",
  FgMagenta: "\x1B[35m",
  FgCyan: "\x1B[36m",
  FgGray: "\x1B[90m",
  BgGray: "\x1B[100m"
};
function isUnixTime(time) {
  const UnixTimeMax = 4102444800;
  return time <= UnixTimeMax;
}
function addStatusColor(text, status, opts) {
  const colorEnabled = opts?.colorEnabled ?? (0, import_color.getColorEnabled)();
  if (colorEnabled) {
    const statusCategory = status / 100 | 0;
    if (statusCategory === 5) {
      return `${ANSI.FgRed}${text}${ANSI.Reset}`;
    }
    if (statusCategory === 4) {
      return `${ANSI.FgYellow}${text}${ANSI.Reset}`;
    }
    if (statusCategory === 3) {
      return `${ANSI.FgCyan}${text}${ANSI.Reset}`;
    }
    if (statusCategory === 2) {
      return `${ANSI.FgGreen}${text}${ANSI.Reset}`;
    }
  }
  return text;
}

// src/debug-log/formatter.ts
var defaultLevelFormatter = (label, level, opts) => {
  const { colorEnabled = (0, import_color2.getColorEnabled)() } = opts ?? {};
  if (colorEnabled) {
    if (level === 10) return `${ANSI.FgGray}${label}${ANSI.Reset}`;
    if (level === 20) return `${ANSI.FgCyan}${label}${ANSI.Reset}`;
    if (level === 30) return `${ANSI.FgGreen}${label}${ANSI.Reset}`;
    if (level === 40) return `${ANSI.FgYellow}${label}${ANSI.Reset}`;
    if (level === 50) return `${ANSI.FgRed}${label}${ANSI.Reset}`;
    if (level === 60) return `${ANSI.FgMagenta}${label}${ANSI.Reset}`;
  }
  return label;
};
var defaultTimeFormatter = (time) => {
  if (!time) {
    return "";
  }
  if (typeof time === "string") {
    return time;
  }
  if (isUnixTime(time)) {
    const unixTime = new Date(time * 1e3);
    return unixTime.toISOString().slice(11, 19);
  }
  const date = new Date(time);
  const ms = date.getMilliseconds().toString().padEnd(3, "0");
  return `${date.toISOString().slice(11, 19)}.${ms}`;
};
var defaultBindingsFormat = (bindings, opts) => {
  const { colorEnabled = (0, import_color2.getColorEnabled)() } = opts ?? {};
  const bindingsStr = JSON.stringify(bindings);
  if (colorEnabled) {
    return `${ANSI.FgGray}${bindingsStr}${ANSI.Reset}`;
  }
  return bindingsStr;
};

// src/debug-log/handler.ts
function createHandler(opts) {
  const colorEnabled = opts?.colorEnabled ?? (0, import_color3.getColorEnabled)();
  const messageKey = opts?.messageKey ?? "msg";
  const requestKey = opts?.requestKey ?? "req";
  const responseKey = opts?.responseKey ?? "res";
  const levelLabelMap = opts?.levelLabelMap ?? import_pino.pino.levels.labels;
  const levelMaxLength = Object.values(levelLabelMap).reduce(
    (max, label) => Math.max(max, label.length),
    0
  );
  const normalLogFormat = opts?.normalLogFormat ?? "[{time}] {levelLabel} - {msg}";
  const httpLogFormat = opts?.httpLogFormat ?? "[{time}] {reqId} {req.method} {req.url} {res.status} ({responseTime}ms) - {msg} {bindings}";
  const timeFormatter = opts?.timeFormatter ?? defaultTimeFormatter;
  const bindingsFormatter = opts?.bindingsFormatter ?? defaultBindingsFormat;
  const levelFormatter = opts?.levelFormatter ?? defaultLevelFormatter;
  const printer = opts?.printer ?? console.log;
  const handler = (obj) => {
    const {
      level,
      time,
      [messageKey]: msg,
      reqId,
      responseTime,
      [requestKey]: req,
      [responseKey]: res,
      ...rest
    } = obj ?? {};
    const timeStr = timeFormatter(time);
    const levelLabel = (levelLabelMap[level] ?? "").toUpperCase().padEnd(levelMaxLength);
    const status = addStatusColor(res?.status?.toString(), res?.status, {
      colorEnabled
    });
    const textMap = {
      time: timeStr,
      level,
      levelLabel: levelFormatter(levelLabel, level, {
        colorEnabled
      }),
      msg,
      reqId: colorEnabled ? `${ANSI.BgGray}${reqId}${ANSI.Reset}` : reqId,
      responseTime,
      "req.method": req?.method,
      "req.url": req?.url,
      "res.status": status,
      // Format and colorize context/bindings if present
      bindings: bindingsFormatter(rest, {
        colorEnabled
      })
    };
    const isHttpLog = !!res;
    const logFormat = isHttpLog ? httpLogFormat : normalLogFormat;
    const output = Object.entries(textMap).reduce(
      (acc, [key, value]) => acc.replace(`{${key}}`, value),
      logFormat
    );
    printer(output);
  };
  return handler;
}

// src/debug-log/index.ts
async function debug_log_default(opts) {
  const handler = opts?._handler ?? createHandler(opts);
  return (0, import_pino_abstract_transport.default)(async (source) => {
    source.on("data", (line) => {
      handler(line);
    });
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createHandler
});
