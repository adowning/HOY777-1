// src/logger.ts
import { defu } from "defu";
var httpCfgSym = Symbol("httpCfgSym");
var PinoLogger = class {
  /**
   * Internal pino logger instance
   *
   * If you want to interact with the internal pino logger,
   * you can use it (not recommended)
   */
  _rootLogger;
  /**
   * Internal child pino logger instance, recreated after each update bindings.
   *
   * If you want to interact with the internal pino logger,
   * you can use it (not recommended)
   */
  _logger;
  // in cloudflare worker, pino logger bindings maybe not available
  // use custom internal bindings
  #bindings = {};
  [httpCfgSym] = {};
  constructor(rootLogger, childOptions) {
    this._rootLogger = rootLogger.child({}, childOptions);
    this._logger = rootLogger;
    this.#bindings = rootLogger.bindings?.();
  }
  /**
   * Get bindings from http log context
   */
  bindings() {
    return this.#bindings;
  }
  /**
   * Clear bindings from http log context
   */
  clearBindings() {
    this.#bindings = {};
    this._logger = this._rootLogger.child(this.#bindings);
    return this;
  }
  /**
   * Assign bindings to http log context
   */
  assign(bindings, opts) {
    this.#bindings = opts?.deep ? defu(bindings, this.#bindings) : { ...this.#bindings, ...bindings };
    this._logger = this._rootLogger.child(this.#bindings);
    return this;
  }
  /**
   * Override response log message
   */
  setResMessage(message) {
    this[httpCfgSym].resMessage = message;
    return this;
  }
  /**
   * Override response log level
   */
  setResLevel(level) {
    this[httpCfgSym].resLevel = level;
    return this;
  }
};
PinoLogger.prototype.trace = function(...args) {
  this._logger.trace(...args);
};
PinoLogger.prototype.debug = function(...args) {
  this._logger.debug(...args);
};
PinoLogger.prototype.info = function(...args) {
  this._logger.info(...args);
};
PinoLogger.prototype.warn = function(...args) {
  this._logger.warn(...args);
};
PinoLogger.prototype.error = function(...args) {
  this._logger.error(...args);
};
PinoLogger.prototype.fatal = function(...args) {
  this._logger.fatal(...args);
};

// src/middleware.ts
import { defu as defu2 } from "defu";
import { env } from "hono/adapter";
import { pino } from "pino";

// src/utils.ts
function getLogger(c) {
  return c.get("logger");
}
function isPino(value) {
  return typeof value === "object" && value !== null && // issue: https://github.com/pinojs/pino/issues/2079
  // pino.symbols.messageKeySym in value
  "info" in value && typeof value.info === "function" && "child" in value && typeof value.child === "function";
}

// src/middleware.ts
var pinoLogger = (opts) => {
  const contextKey = opts?.contextKey ?? "logger";
  let rootLogger = createStaticRootLogger(opts?.pino);
  return async (c, next) => {
    const [dynamicRootLogger, loggerChildOptions] = parseDynamicRootLogger(
      opts?.pino,
      c
    );
    rootLogger ??= dynamicRootLogger ?? getDefaultRootLogger();
    const logger2 = new PinoLogger(rootLogger, loggerChildOptions);
    c.set(contextKey, logger2);
    if (opts?.http === false) {
      await next();
      return;
    }
    let bindings = opts?.http?.onReqBindings?.(c) ?? {
      req: {
        url: c.req.path,
        method: c.req.method,
        headers: c.req.header()
      }
    };
    logger2.assign(bindings);
    const referRequestIdKey = opts?.http?.referRequestIdKey ?? "requestId";
    if (referRequestIdKey in c.var) {
      bindings.reqId = c.var[referRequestIdKey];
    } else if (opts?.http?.reqId !== false) {
      bindings.reqId = opts?.http?.reqId?.() ?? defaultReqIdGenerator();
    }
    if (opts?.http?.onReqMessage) {
      const level = opts.http.onReqLevel?.(c) ?? "info";
      const msg = await opts.http.onReqMessage(c);
      logger2[level](bindings, msg);
    }
    if (opts?.http?.responseTime ?? true) {
      const startTime = performance.now();
      await next();
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      bindings.responseTime = responseTime;
    } else {
      await next();
    }
    if (opts?.http?.onResMessage !== false) {
      const onResBindings = opts?.http?.onResBindings?.(c) ?? {
        res: {
          status: c.res.status,
          headers: c.res.headers
        }
      };
      bindings = defu2(bindings, onResBindings);
      const level = logger2[httpCfgSym].resLevel ?? opts?.http?.onResLevel?.(c) ?? (c.error ? "error" : "info");
      const msg = logger2[httpCfgSym].resMessage ?? (opts?.http?.onResMessage ? await opts?.http?.onResMessage(c) : void 0) ?? (c.error ? c.error.message : "Request completed");
      logger2[level](bindings, msg);
    }
  };
};
var logger = pinoLogger;
var _defaultReqId = 0;
var defaultReqIdGenerator = () => {
  _defaultReqId += 1;
  return _defaultReqId;
};
var createStaticRootLogger = (opt) => {
  if (typeof opt === "function") return null;
  if (isPino(opt)) return opt;
  return pino(opt);
};
var parseDynamicRootLogger = (opt, c) => {
  if (opt === void 0) {
    const { LOG_LEVEL } = env(c);
    return [
      void 0,
      {
        level: LOG_LEVEL ?? "info"
      }
    ];
  }
  if (typeof opt !== "function") return [void 0, void 0];
  const v = opt(c);
  if (isPino(v)) return [v, void 0];
  return [void 0, v];
};
var _defaultRootLogger;
var getDefaultRootLogger = () => {
  _defaultRootLogger ??= pino();
  return _defaultRootLogger;
};
export {
  PinoLogger,
  getLogger,
  httpCfgSym,
  logger,
  pinoLogger
};
//! in cloudflare worker, pino logger bindings maybe not available
