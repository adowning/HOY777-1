import { ref, computed, isRef, nextTick, watch, onMounted, onUnmounted, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, createElementVNode, createVNode, Transition, withCtx, withDirectives, vShow, createCommentVNode, createBlock, renderSlot } from "vue";
var style = "";
const MAIN_IMAGE_LOAD_SUCCESS = "success";
const MAIN_IMAGE_LOAD_ERROR = "error";
const IMAGE_POLL_INTERVAL = 10;
const IMAGE_ASPECT_RATIO = 0.5625;
const INTERSECTION_THRESHOLD = 0.2;
const useImage = (element) => {
  const image = new Image();
  const width = ref(0);
  const height = ref(0);
  const aspectRatio = computed(() => {
    return width.value ? height.value / width.value : IMAGE_ASPECT_RATIO;
  });
  const pollImageData = setInterval(() => {
    if (image && image.width) {
      clearInterval(pollImageData);
      width.value = image.width;
      height.value = image.height;
    }
  }, IMAGE_POLL_INTERVAL);
  const imageRenderer = (imageNode) => {
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    canvas.setAttribute("hidden", true);
    document.body.appendChild(canvas);
    canvas.getContext("2d").drawImage(imageNode, 0, 0);
    document.body.removeChild(canvas);
  };
  const loadImage = () => {
    const imageNode = isRef(element) ? element.value : element;
    const src = imageNode.src;
    image.src = src;
    if (image.complete) {
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      image.onload = () => {
        imageRenderer(imageNode);
        nextTick(resolve);
      };
      image.onerror = reject;
    });
  };
  return {
    width,
    height,
    aspectRatio,
    loadImage
  };
};
const useIntersect = (element) => {
  const isIntersected = ref(false);
  const options = { threshold: INTERSECTION_THRESHOLD };
  const observer = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting) {
      isIntersected.value = true;
      observer.disconnect();
    }
  }, options);
  const watchIntersectionOnce = (callback) => {
    const stop = watch(isIntersected, (is) => {
      if (is) {
        nextTick().then(callback);
        stop();
      }
    }, { immediate: true });
  };
  onMounted(() => {
    const el = isRef(element) ? element.value : element;
    observer.observe(el);
  });
  onUnmounted(() => {
    observer.disconnect();
  });
  return {
    watchIntersectionOnce,
    isIntersected
  };
};
const _hoisted_1 = ["src", "alt", "title"];
const _hoisted_2 = ["loading", "src"];
const _hoisted_3 = {
  key: 1,
  class: "v-progressive-image-slot-default"
};
const _sfc_main = {
  props: {
    src: String,
    placeholderSrc: String,
    fallbackSrc: String,
    alt: String,
    title: String,
    customClass: String,
    blur: [Number, String],
    lazyPlaceholder: {
      type: Boolean,
      default: false
    },
    delay: {
      type: [Number, String],
      default: 0
    },
    objectCover: {
      type: Boolean,
      default: false
    }
  },
  emits: [MAIN_IMAGE_LOAD_SUCCESS, MAIN_IMAGE_LOAD_ERROR],
  setup(__props, { emit }) {
    const props = __props;
    const rootRef = ref(null);
    const imageRef = ref(null);
    const isMainImageRendered = ref(false);
    const isFallbackImageRendered = ref(false);
    const { isIntersected, watchIntersectionOnce } = useIntersect(rootRef);
    const { loadImage, aspectRatio, width } = useImage(imageRef);
    const isLoading = computed(() => !isMainImageRendered.value);
    const paddingHack = computed(() => ({
      paddingBottom: `${aspectRatio.value * 100}%`
    }));
    const componentStyle = computed(() => {
      if (props.objectCover || width.value === 0) {
        return;
      }
      return {
        maxWidth: `${width.value}px`
      };
    });
    const imageClasses = computed(() => {
      return [
        props.customClass,
        {
          "v-progressive-image-object-cover": props.objectCover,
          "v-progressive-image-loading": isLoading.value
        }
      ];
    });
    const mainImageHandler = () => {
      loadImage().then(() => {
        setTimeout(() => {
          isMainImageRendered.value = true;
          emit(MAIN_IMAGE_LOAD_SUCCESS);
        }, props.delay * 1);
      }).catch((error) => {
        isMainImageRendered.value = true;
        isFallbackImageRendered.value = true;
        emit(MAIN_IMAGE_LOAD_ERROR, error);
      });
    };
    onMounted(() => {
      if (props.placeholderSrc && props.blur) {
        document.documentElement.style.setProperty("--progressive-image-blur", `${props.blur * 1}px`);
      }
      if (props.src) {
        watchIntersectionOnce(mainImageHandler);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootRef",
        ref: rootRef,
        class: normalizeClass(["v-progressive-image", unref(imageClasses)]),
        style: normalizeStyle(unref(componentStyle))
      }, [
        createElementVNode("div", {
          style: normalizeStyle(unref(paddingHack))
        }, [
          createVNode(Transition, {
            css: !__props.placeholderSrc,
            name: "v-progressive-image-main-fade",
            appear: ""
          }, {
            default: withCtx(() => [
              unref(isIntersected) ? withDirectives((openBlock(), createElementBlock("img", {
                key: 0,
                ref_key: "imageRef",
                ref: imageRef,
                class: "v-progressive-image-main",
                src: isFallbackImageRendered.value ? __props.fallbackSrc : __props.src,
                alt: __props.alt,
                title: __props.title
              }, null, 8, _hoisted_1)), [
                [vShow, isMainImageRendered.value]
              ]) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["css"]),
          __props.placeholderSrc ? (openBlock(), createBlock(Transition, {
            key: 0,
            name: "v-progressive-image-placeholder-fade",
            appear: ""
          }, {
            default: withCtx(() => [
              unref(isLoading) ? (openBlock(), createElementBlock("img", {
                key: 0,
                class: "v-progressive-image-placeholder",
                loading: __props.lazyPlaceholder ? "lazy" : "eager",
                src: __props.placeholderSrc
              }, null, 8, _hoisted_2)) : createCommentVNode("", true)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_3, [
            renderSlot(_ctx.$slots, "default", { isLoading: unref(isLoading) })
          ])) : createCommentVNode("", true)
        ], 4)
      ], 6);
    };
  }
};
const install = (app, props = {}) => {
  Object.keys(props).forEach((key) => {
    _sfc_main.props[key].default = props[key];
  });
  app.component("ProgressiveImage", _sfc_main);
};
export { _sfc_main as ProgressiveImage, install as default, install };
